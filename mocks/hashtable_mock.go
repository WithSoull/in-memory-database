package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// HashtableMock implements inmemory.Hashtable
type HashtableMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDel          func(s1 string)
	inspectFuncDel   func(s1 string)
	afterDelCounter  uint64
	beforeDelCounter uint64
	DelMock          mHashtableMockDel

	funcGet          func(s1 string) (s2 string, b1 bool)
	inspectFuncGet   func(s1 string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mHashtableMockGet

	funcSet          func(s1 string, s2 string)
	inspectFuncSet   func(s1 string, s2 string)
	afterSetCounter  uint64
	beforeSetCounter uint64
	SetMock          mHashtableMockSet
}

// NewHashtableMock returns a mock for inmemory.Hashtable
func NewHashtableMock(t minimock.Tester) *HashtableMock {
	m := &HashtableMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DelMock = mHashtableMockDel{mock: m}
	m.DelMock.callArgs = []*HashtableMockDelParams{}

	m.GetMock = mHashtableMockGet{mock: m}
	m.GetMock.callArgs = []*HashtableMockGetParams{}

	m.SetMock = mHashtableMockSet{mock: m}
	m.SetMock.callArgs = []*HashtableMockSetParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mHashtableMockDel struct {
	mock               *HashtableMock
	defaultExpectation *HashtableMockDelExpectation
	expectations       []*HashtableMockDelExpectation

	callArgs []*HashtableMockDelParams
	mutex    sync.RWMutex
}

// HashtableMockDelExpectation specifies expectation struct of the Hashtable.Del
type HashtableMockDelExpectation struct {
	mock   *HashtableMock
	params *HashtableMockDelParams

	Counter uint64
}

// HashtableMockDelParams contains parameters of the Hashtable.Del
type HashtableMockDelParams struct {
	s1 string
}

// Expect sets up expected params for Hashtable.Del
func (mmDel *mHashtableMockDel) Expect(s1 string) *mHashtableMockDel {
	if mmDel.mock.funcDel != nil {
		mmDel.mock.t.Fatalf("HashtableMock.Del mock is already set by Set")
	}

	if mmDel.defaultExpectation == nil {
		mmDel.defaultExpectation = &HashtableMockDelExpectation{}
	}

	mmDel.defaultExpectation.params = &HashtableMockDelParams{s1}
	for _, e := range mmDel.expectations {
		if minimock.Equal(e.params, mmDel.defaultExpectation.params) {
			mmDel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDel.defaultExpectation.params)
		}
	}

	return mmDel
}

// Inspect accepts an inspector function that has same arguments as the Hashtable.Del
func (mmDel *mHashtableMockDel) Inspect(f func(s1 string)) *mHashtableMockDel {
	if mmDel.mock.inspectFuncDel != nil {
		mmDel.mock.t.Fatalf("Inspect function is already set for HashtableMock.Del")
	}

	mmDel.mock.inspectFuncDel = f

	return mmDel
}

// Return sets up results that will be returned by Hashtable.Del
func (mmDel *mHashtableMockDel) Return() *HashtableMock {
	if mmDel.mock.funcDel != nil {
		mmDel.mock.t.Fatalf("HashtableMock.Del mock is already set by Set")
	}

	if mmDel.defaultExpectation == nil {
		mmDel.defaultExpectation = &HashtableMockDelExpectation{mock: mmDel.mock}
	}

	return mmDel.mock
}

// Set uses given function f to mock the Hashtable.Del method
func (mmDel *mHashtableMockDel) Set(f func(s1 string)) *HashtableMock {
	if mmDel.defaultExpectation != nil {
		mmDel.mock.t.Fatalf("Default expectation is already set for the Hashtable.Del method")
	}

	if len(mmDel.expectations) > 0 {
		mmDel.mock.t.Fatalf("Some expectations are already set for the Hashtable.Del method")
	}

	mmDel.mock.funcDel = f
	return mmDel.mock
}

// Del implements inmemory.Hashtable
func (mmDel *HashtableMock) Del(s1 string) {
	mm_atomic.AddUint64(&mmDel.beforeDelCounter, 1)
	defer mm_atomic.AddUint64(&mmDel.afterDelCounter, 1)

	if mmDel.inspectFuncDel != nil {
		mmDel.inspectFuncDel(s1)
	}

	mm_params := HashtableMockDelParams{s1}

	// Record call args
	mmDel.DelMock.mutex.Lock()
	mmDel.DelMock.callArgs = append(mmDel.DelMock.callArgs, &mm_params)
	mmDel.DelMock.mutex.Unlock()

	for _, e := range mmDel.DelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDel.DelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDel.DelMock.defaultExpectation.Counter, 1)
		mm_want := mmDel.DelMock.defaultExpectation.params
		mm_got := HashtableMockDelParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDel.t.Errorf("HashtableMock.Del got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDel.funcDel != nil {
		mmDel.funcDel(s1)
		return
	}
	mmDel.t.Fatalf("Unexpected call to HashtableMock.Del. %v", s1)

}

// DelAfterCounter returns a count of finished HashtableMock.Del invocations
func (mmDel *HashtableMock) DelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDel.afterDelCounter)
}

// DelBeforeCounter returns a count of HashtableMock.Del invocations
func (mmDel *HashtableMock) DelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDel.beforeDelCounter)
}

// Calls returns a list of arguments used in each call to HashtableMock.Del.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDel *mHashtableMockDel) Calls() []*HashtableMockDelParams {
	mmDel.mutex.RLock()

	argCopy := make([]*HashtableMockDelParams, len(mmDel.callArgs))
	copy(argCopy, mmDel.callArgs)

	mmDel.mutex.RUnlock()

	return argCopy
}

// MinimockDelDone returns true if the count of the Del invocations corresponds
// the number of defined expectations
func (m *HashtableMock) MinimockDelDone() bool {
	for _, e := range m.DelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDelCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDel != nil && mm_atomic.LoadUint64(&m.afterDelCounter) < 1 {
		return false
	}
	return true
}

// MinimockDelInspect logs each unmet expectation
func (m *HashtableMock) MinimockDelInspect() {
	for _, e := range m.DelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HashtableMock.Del with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDelCounter) < 1 {
		if m.DelMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HashtableMock.Del")
		} else {
			m.t.Errorf("Expected call to HashtableMock.Del with params: %#v", *m.DelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDel != nil && mm_atomic.LoadUint64(&m.afterDelCounter) < 1 {
		m.t.Error("Expected call to HashtableMock.Del")
	}
}

type mHashtableMockGet struct {
	mock               *HashtableMock
	defaultExpectation *HashtableMockGetExpectation
	expectations       []*HashtableMockGetExpectation

	callArgs []*HashtableMockGetParams
	mutex    sync.RWMutex
}

// HashtableMockGetExpectation specifies expectation struct of the Hashtable.Get
type HashtableMockGetExpectation struct {
	mock    *HashtableMock
	params  *HashtableMockGetParams
	results *HashtableMockGetResults
	Counter uint64
}

// HashtableMockGetParams contains parameters of the Hashtable.Get
type HashtableMockGetParams struct {
	s1 string
}

// HashtableMockGetResults contains results of the Hashtable.Get
type HashtableMockGetResults struct {
	s2 string
	b1 bool
}

// Expect sets up expected params for Hashtable.Get
func (mmGet *mHashtableMockGet) Expect(s1 string) *mHashtableMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("HashtableMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &HashtableMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &HashtableMockGetParams{s1}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the Hashtable.Get
func (mmGet *mHashtableMockGet) Inspect(f func(s1 string)) *mHashtableMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for HashtableMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by Hashtable.Get
func (mmGet *mHashtableMockGet) Return(s2 string, b1 bool) *HashtableMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("HashtableMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &HashtableMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &HashtableMockGetResults{s2, b1}
	return mmGet.mock
}

// Set uses given function f to mock the Hashtable.Get method
func (mmGet *mHashtableMockGet) Set(f func(s1 string) (s2 string, b1 bool)) *HashtableMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the Hashtable.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the Hashtable.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the Hashtable.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mHashtableMockGet) When(s1 string) *HashtableMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("HashtableMock.Get mock is already set by Set")
	}

	expectation := &HashtableMockGetExpectation{
		mock:   mmGet.mock,
		params: &HashtableMockGetParams{s1},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up Hashtable.Get return parameters for the expectation previously defined by the When method
func (e *HashtableMockGetExpectation) Then(s2 string, b1 bool) *HashtableMock {
	e.results = &HashtableMockGetResults{s2, b1}
	return e.mock
}

// Get implements inmemory.Hashtable
func (mmGet *HashtableMock) Get(s1 string) (s2 string, b1 bool) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(s1)
	}

	mm_params := HashtableMockGetParams{s1}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2, e.results.b1
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := HashtableMockGetParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("HashtableMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the HashtableMock.Get")
		}
		return (*mm_results).s2, (*mm_results).b1
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(s1)
	}
	mmGet.t.Fatalf("Unexpected call to HashtableMock.Get. %v", s1)
	return
}

// GetAfterCounter returns a count of finished HashtableMock.Get invocations
func (mmGet *HashtableMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of HashtableMock.Get invocations
func (mmGet *HashtableMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to HashtableMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mHashtableMockGet) Calls() []*HashtableMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*HashtableMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *HashtableMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *HashtableMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HashtableMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HashtableMock.Get")
		} else {
			m.t.Errorf("Expected call to HashtableMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to HashtableMock.Get")
	}
}

type mHashtableMockSet struct {
	mock               *HashtableMock
	defaultExpectation *HashtableMockSetExpectation
	expectations       []*HashtableMockSetExpectation

	callArgs []*HashtableMockSetParams
	mutex    sync.RWMutex
}

// HashtableMockSetExpectation specifies expectation struct of the Hashtable.Set
type HashtableMockSetExpectation struct {
	mock   *HashtableMock
	params *HashtableMockSetParams

	Counter uint64
}

// HashtableMockSetParams contains parameters of the Hashtable.Set
type HashtableMockSetParams struct {
	s1 string
	s2 string
}

// Expect sets up expected params for Hashtable.Set
func (mmSet *mHashtableMockSet) Expect(s1 string, s2 string) *mHashtableMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("HashtableMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &HashtableMockSetExpectation{}
	}

	mmSet.defaultExpectation.params = &HashtableMockSetParams{s1, s2}
	for _, e := range mmSet.expectations {
		if minimock.Equal(e.params, mmSet.defaultExpectation.params) {
			mmSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSet.defaultExpectation.params)
		}
	}

	return mmSet
}

// Inspect accepts an inspector function that has same arguments as the Hashtable.Set
func (mmSet *mHashtableMockSet) Inspect(f func(s1 string, s2 string)) *mHashtableMockSet {
	if mmSet.mock.inspectFuncSet != nil {
		mmSet.mock.t.Fatalf("Inspect function is already set for HashtableMock.Set")
	}

	mmSet.mock.inspectFuncSet = f

	return mmSet
}

// Return sets up results that will be returned by Hashtable.Set
func (mmSet *mHashtableMockSet) Return() *HashtableMock {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("HashtableMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &HashtableMockSetExpectation{mock: mmSet.mock}
	}

	return mmSet.mock
}

// Set uses given function f to mock the Hashtable.Set method
func (mmSet *mHashtableMockSet) Set(f func(s1 string, s2 string)) *HashtableMock {
	if mmSet.defaultExpectation != nil {
		mmSet.mock.t.Fatalf("Default expectation is already set for the Hashtable.Set method")
	}

	if len(mmSet.expectations) > 0 {
		mmSet.mock.t.Fatalf("Some expectations are already set for the Hashtable.Set method")
	}

	mmSet.mock.funcSet = f
	return mmSet.mock
}

// Set implements inmemory.Hashtable
func (mmSet *HashtableMock) Set(s1 string, s2 string) {
	mm_atomic.AddUint64(&mmSet.beforeSetCounter, 1)
	defer mm_atomic.AddUint64(&mmSet.afterSetCounter, 1)

	if mmSet.inspectFuncSet != nil {
		mmSet.inspectFuncSet(s1, s2)
	}

	mm_params := HashtableMockSetParams{s1, s2}

	// Record call args
	mmSet.SetMock.mutex.Lock()
	mmSet.SetMock.callArgs = append(mmSet.SetMock.callArgs, &mm_params)
	mmSet.SetMock.mutex.Unlock()

	for _, e := range mmSet.SetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSet.SetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSet.SetMock.defaultExpectation.Counter, 1)
		mm_want := mmSet.SetMock.defaultExpectation.params
		mm_got := HashtableMockSetParams{s1, s2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSet.t.Errorf("HashtableMock.Set got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSet.funcSet != nil {
		mmSet.funcSet(s1, s2)
		return
	}
	mmSet.t.Fatalf("Unexpected call to HashtableMock.Set. %v %v", s1, s2)

}

// SetAfterCounter returns a count of finished HashtableMock.Set invocations
func (mmSet *HashtableMock) SetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.afterSetCounter)
}

// SetBeforeCounter returns a count of HashtableMock.Set invocations
func (mmSet *HashtableMock) SetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.beforeSetCounter)
}

// Calls returns a list of arguments used in each call to HashtableMock.Set.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSet *mHashtableMockSet) Calls() []*HashtableMockSetParams {
	mmSet.mutex.RLock()

	argCopy := make([]*HashtableMockSetParams, len(mmSet.callArgs))
	copy(argCopy, mmSet.callArgs)

	mmSet.mutex.RUnlock()

	return argCopy
}

// MinimockSetDone returns true if the count of the Set invocations corresponds
// the number of defined expectations
func (m *HashtableMock) MinimockSetDone() bool {
	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSet != nil && mm_atomic.LoadUint64(&m.afterSetCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetInspect logs each unmet expectation
func (m *HashtableMock) MinimockSetInspect() {
	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HashtableMock.Set with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetCounter) < 1 {
		if m.SetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HashtableMock.Set")
		} else {
			m.t.Errorf("Expected call to HashtableMock.Set with params: %#v", *m.SetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSet != nil && mm_atomic.LoadUint64(&m.afterSetCounter) < 1 {
		m.t.Error("Expected call to HashtableMock.Set")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *HashtableMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDelInspect()

			m.MinimockGetInspect()

			m.MinimockSetInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *HashtableMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *HashtableMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDelDone() &&
		m.MinimockGetDone() &&
		m.MinimockSetDone()
}

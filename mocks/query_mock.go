package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// QueryMock implements compute.Query
type QueryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcArguments          func() (sa1 []string)
	inspectFuncArguments   func()
	afterArgumentsCounter  uint64
	beforeArgumentsCounter uint64
	ArgumentsMock          mQueryMockArguments

	funcCommandID          func() (i1 int64)
	inspectFuncCommandID   func()
	afterCommandIDCounter  uint64
	beforeCommandIDCounter uint64
	CommandIDMock          mQueryMockCommandID
}

// NewQueryMock returns a mock for compute.Query
func NewQueryMock(t minimock.Tester) *QueryMock {
	m := &QueryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ArgumentsMock = mQueryMockArguments{mock: m}

	m.CommandIDMock = mQueryMockCommandID{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mQueryMockArguments struct {
	mock               *QueryMock
	defaultExpectation *QueryMockArgumentsExpectation
	expectations       []*QueryMockArgumentsExpectation
}

// QueryMockArgumentsExpectation specifies expectation struct of the Query.Arguments
type QueryMockArgumentsExpectation struct {
	mock *QueryMock

	results *QueryMockArgumentsResults
	Counter uint64
}

// QueryMockArgumentsResults contains results of the Query.Arguments
type QueryMockArgumentsResults struct {
	sa1 []string
}

// Expect sets up expected params for Query.Arguments
func (mmArguments *mQueryMockArguments) Expect() *mQueryMockArguments {
	if mmArguments.mock.funcArguments != nil {
		mmArguments.mock.t.Fatalf("QueryMock.Arguments mock is already set by Set")
	}

	if mmArguments.defaultExpectation == nil {
		mmArguments.defaultExpectation = &QueryMockArgumentsExpectation{}
	}

	return mmArguments
}

// Inspect accepts an inspector function that has same arguments as the Query.Arguments
func (mmArguments *mQueryMockArguments) Inspect(f func()) *mQueryMockArguments {
	if mmArguments.mock.inspectFuncArguments != nil {
		mmArguments.mock.t.Fatalf("Inspect function is already set for QueryMock.Arguments")
	}

	mmArguments.mock.inspectFuncArguments = f

	return mmArguments
}

// Return sets up results that will be returned by Query.Arguments
func (mmArguments *mQueryMockArguments) Return(sa1 []string) *QueryMock {
	if mmArguments.mock.funcArguments != nil {
		mmArguments.mock.t.Fatalf("QueryMock.Arguments mock is already set by Set")
	}

	if mmArguments.defaultExpectation == nil {
		mmArguments.defaultExpectation = &QueryMockArgumentsExpectation{mock: mmArguments.mock}
	}
	mmArguments.defaultExpectation.results = &QueryMockArgumentsResults{sa1}
	return mmArguments.mock
}

// Set uses given function f to mock the Query.Arguments method
func (mmArguments *mQueryMockArguments) Set(f func() (sa1 []string)) *QueryMock {
	if mmArguments.defaultExpectation != nil {
		mmArguments.mock.t.Fatalf("Default expectation is already set for the Query.Arguments method")
	}

	if len(mmArguments.expectations) > 0 {
		mmArguments.mock.t.Fatalf("Some expectations are already set for the Query.Arguments method")
	}

	mmArguments.mock.funcArguments = f
	return mmArguments.mock
}

// Arguments implements compute.Query
func (mmArguments *QueryMock) Arguments() (sa1 []string) {
	mm_atomic.AddUint64(&mmArguments.beforeArgumentsCounter, 1)
	defer mm_atomic.AddUint64(&mmArguments.afterArgumentsCounter, 1)

	if mmArguments.inspectFuncArguments != nil {
		mmArguments.inspectFuncArguments()
	}

	if mmArguments.ArgumentsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmArguments.ArgumentsMock.defaultExpectation.Counter, 1)

		mm_results := mmArguments.ArgumentsMock.defaultExpectation.results
		if mm_results == nil {
			mmArguments.t.Fatal("No results are set for the QueryMock.Arguments")
		}
		return (*mm_results).sa1
	}
	if mmArguments.funcArguments != nil {
		return mmArguments.funcArguments()
	}
	mmArguments.t.Fatalf("Unexpected call to QueryMock.Arguments.")
	return
}

// ArgumentsAfterCounter returns a count of finished QueryMock.Arguments invocations
func (mmArguments *QueryMock) ArgumentsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmArguments.afterArgumentsCounter)
}

// ArgumentsBeforeCounter returns a count of QueryMock.Arguments invocations
func (mmArguments *QueryMock) ArgumentsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmArguments.beforeArgumentsCounter)
}

// MinimockArgumentsDone returns true if the count of the Arguments invocations corresponds
// the number of defined expectations
func (m *QueryMock) MinimockArgumentsDone() bool {
	for _, e := range m.ArgumentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ArgumentsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterArgumentsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcArguments != nil && mm_atomic.LoadUint64(&m.afterArgumentsCounter) < 1 {
		return false
	}
	return true
}

// MinimockArgumentsInspect logs each unmet expectation
func (m *QueryMock) MinimockArgumentsInspect() {
	for _, e := range m.ArgumentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to QueryMock.Arguments")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ArgumentsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterArgumentsCounter) < 1 {
		m.t.Error("Expected call to QueryMock.Arguments")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcArguments != nil && mm_atomic.LoadUint64(&m.afterArgumentsCounter) < 1 {
		m.t.Error("Expected call to QueryMock.Arguments")
	}
}

type mQueryMockCommandID struct {
	mock               *QueryMock
	defaultExpectation *QueryMockCommandIDExpectation
	expectations       []*QueryMockCommandIDExpectation
}

// QueryMockCommandIDExpectation specifies expectation struct of the Query.CommandID
type QueryMockCommandIDExpectation struct {
	mock *QueryMock

	results *QueryMockCommandIDResults
	Counter uint64
}

// QueryMockCommandIDResults contains results of the Query.CommandID
type QueryMockCommandIDResults struct {
	i1 int64
}

// Expect sets up expected params for Query.CommandID
func (mmCommandID *mQueryMockCommandID) Expect() *mQueryMockCommandID {
	if mmCommandID.mock.funcCommandID != nil {
		mmCommandID.mock.t.Fatalf("QueryMock.CommandID mock is already set by Set")
	}

	if mmCommandID.defaultExpectation == nil {
		mmCommandID.defaultExpectation = &QueryMockCommandIDExpectation{}
	}

	return mmCommandID
}

// Inspect accepts an inspector function that has same arguments as the Query.CommandID
func (mmCommandID *mQueryMockCommandID) Inspect(f func()) *mQueryMockCommandID {
	if mmCommandID.mock.inspectFuncCommandID != nil {
		mmCommandID.mock.t.Fatalf("Inspect function is already set for QueryMock.CommandID")
	}

	mmCommandID.mock.inspectFuncCommandID = f

	return mmCommandID
}

// Return sets up results that will be returned by Query.CommandID
func (mmCommandID *mQueryMockCommandID) Return(i1 int64) *QueryMock {
	if mmCommandID.mock.funcCommandID != nil {
		mmCommandID.mock.t.Fatalf("QueryMock.CommandID mock is already set by Set")
	}

	if mmCommandID.defaultExpectation == nil {
		mmCommandID.defaultExpectation = &QueryMockCommandIDExpectation{mock: mmCommandID.mock}
	}
	mmCommandID.defaultExpectation.results = &QueryMockCommandIDResults{i1}
	return mmCommandID.mock
}

// Set uses given function f to mock the Query.CommandID method
func (mmCommandID *mQueryMockCommandID) Set(f func() (i1 int64)) *QueryMock {
	if mmCommandID.defaultExpectation != nil {
		mmCommandID.mock.t.Fatalf("Default expectation is already set for the Query.CommandID method")
	}

	if len(mmCommandID.expectations) > 0 {
		mmCommandID.mock.t.Fatalf("Some expectations are already set for the Query.CommandID method")
	}

	mmCommandID.mock.funcCommandID = f
	return mmCommandID.mock
}

// CommandID implements compute.Query
func (mmCommandID *QueryMock) CommandID() (i1 int64) {
	mm_atomic.AddUint64(&mmCommandID.beforeCommandIDCounter, 1)
	defer mm_atomic.AddUint64(&mmCommandID.afterCommandIDCounter, 1)

	if mmCommandID.inspectFuncCommandID != nil {
		mmCommandID.inspectFuncCommandID()
	}

	if mmCommandID.CommandIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommandID.CommandIDMock.defaultExpectation.Counter, 1)

		mm_results := mmCommandID.CommandIDMock.defaultExpectation.results
		if mm_results == nil {
			mmCommandID.t.Fatal("No results are set for the QueryMock.CommandID")
		}
		return (*mm_results).i1
	}
	if mmCommandID.funcCommandID != nil {
		return mmCommandID.funcCommandID()
	}
	mmCommandID.t.Fatalf("Unexpected call to QueryMock.CommandID.")
	return
}

// CommandIDAfterCounter returns a count of finished QueryMock.CommandID invocations
func (mmCommandID *QueryMock) CommandIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommandID.afterCommandIDCounter)
}

// CommandIDBeforeCounter returns a count of QueryMock.CommandID invocations
func (mmCommandID *QueryMock) CommandIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommandID.beforeCommandIDCounter)
}

// MinimockCommandIDDone returns true if the count of the CommandID invocations corresponds
// the number of defined expectations
func (m *QueryMock) MinimockCommandIDDone() bool {
	for _, e := range m.CommandIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommandIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommandIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommandID != nil && mm_atomic.LoadUint64(&m.afterCommandIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockCommandIDInspect logs each unmet expectation
func (m *QueryMock) MinimockCommandIDInspect() {
	for _, e := range m.CommandIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to QueryMock.CommandID")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommandIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommandIDCounter) < 1 {
		m.t.Error("Expected call to QueryMock.CommandID")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommandID != nil && mm_atomic.LoadUint64(&m.afterCommandIDCounter) < 1 {
		m.t.Error("Expected call to QueryMock.CommandID")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *QueryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockArgumentsInspect()

			m.MinimockCommandIDInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *QueryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *QueryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockArgumentsDone() &&
		m.MinimockCommandIDDone()
}

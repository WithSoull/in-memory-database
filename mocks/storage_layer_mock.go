package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StorageLayerMock implements database.storageLayer
type StorageLayerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDel          func(ctx context.Context, s1 string) (err error)
	inspectFuncDel   func(ctx context.Context, s1 string)
	afterDelCounter  uint64
	beforeDelCounter uint64
	DelMock          mStorageLayerMockDel

	funcGet          func(ctx context.Context, s1 string) (s2 string, err error)
	inspectFuncGet   func(ctx context.Context, s1 string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mStorageLayerMockGet

	funcSet          func(ctx context.Context, s1 string, s2 string) (err error)
	inspectFuncSet   func(ctx context.Context, s1 string, s2 string)
	afterSetCounter  uint64
	beforeSetCounter uint64
	SetMock          mStorageLayerMockSet
}

// NewStorageLayerMock returns a mock for database.storageLayer
func NewStorageLayerMock(t minimock.Tester) *StorageLayerMock {
	m := &StorageLayerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DelMock = mStorageLayerMockDel{mock: m}
	m.DelMock.callArgs = []*StorageLayerMockDelParams{}

	m.GetMock = mStorageLayerMockGet{mock: m}
	m.GetMock.callArgs = []*StorageLayerMockGetParams{}

	m.SetMock = mStorageLayerMockSet{mock: m}
	m.SetMock.callArgs = []*StorageLayerMockSetParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStorageLayerMockDel struct {
	mock               *StorageLayerMock
	defaultExpectation *StorageLayerMockDelExpectation
	expectations       []*StorageLayerMockDelExpectation

	callArgs []*StorageLayerMockDelParams
	mutex    sync.RWMutex
}

// StorageLayerMockDelExpectation specifies expectation struct of the storageLayer.Del
type StorageLayerMockDelExpectation struct {
	mock    *StorageLayerMock
	params  *StorageLayerMockDelParams
	results *StorageLayerMockDelResults
	Counter uint64
}

// StorageLayerMockDelParams contains parameters of the storageLayer.Del
type StorageLayerMockDelParams struct {
	ctx context.Context
	s1  string
}

// StorageLayerMockDelResults contains results of the storageLayer.Del
type StorageLayerMockDelResults struct {
	err error
}

// Expect sets up expected params for storageLayer.Del
func (mmDel *mStorageLayerMockDel) Expect(ctx context.Context, s1 string) *mStorageLayerMockDel {
	if mmDel.mock.funcDel != nil {
		mmDel.mock.t.Fatalf("StorageLayerMock.Del mock is already set by Set")
	}

	if mmDel.defaultExpectation == nil {
		mmDel.defaultExpectation = &StorageLayerMockDelExpectation{}
	}

	mmDel.defaultExpectation.params = &StorageLayerMockDelParams{ctx, s1}
	for _, e := range mmDel.expectations {
		if minimock.Equal(e.params, mmDel.defaultExpectation.params) {
			mmDel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDel.defaultExpectation.params)
		}
	}

	return mmDel
}

// Inspect accepts an inspector function that has same arguments as the storageLayer.Del
func (mmDel *mStorageLayerMockDel) Inspect(f func(ctx context.Context, s1 string)) *mStorageLayerMockDel {
	if mmDel.mock.inspectFuncDel != nil {
		mmDel.mock.t.Fatalf("Inspect function is already set for StorageLayerMock.Del")
	}

	mmDel.mock.inspectFuncDel = f

	return mmDel
}

// Return sets up results that will be returned by storageLayer.Del
func (mmDel *mStorageLayerMockDel) Return(err error) *StorageLayerMock {
	if mmDel.mock.funcDel != nil {
		mmDel.mock.t.Fatalf("StorageLayerMock.Del mock is already set by Set")
	}

	if mmDel.defaultExpectation == nil {
		mmDel.defaultExpectation = &StorageLayerMockDelExpectation{mock: mmDel.mock}
	}
	mmDel.defaultExpectation.results = &StorageLayerMockDelResults{err}
	return mmDel.mock
}

// Set uses given function f to mock the storageLayer.Del method
func (mmDel *mStorageLayerMockDel) Set(f func(ctx context.Context, s1 string) (err error)) *StorageLayerMock {
	if mmDel.defaultExpectation != nil {
		mmDel.mock.t.Fatalf("Default expectation is already set for the storageLayer.Del method")
	}

	if len(mmDel.expectations) > 0 {
		mmDel.mock.t.Fatalf("Some expectations are already set for the storageLayer.Del method")
	}

	mmDel.mock.funcDel = f
	return mmDel.mock
}

// When sets expectation for the storageLayer.Del which will trigger the result defined by the following
// Then helper
func (mmDel *mStorageLayerMockDel) When(ctx context.Context, s1 string) *StorageLayerMockDelExpectation {
	if mmDel.mock.funcDel != nil {
		mmDel.mock.t.Fatalf("StorageLayerMock.Del mock is already set by Set")
	}

	expectation := &StorageLayerMockDelExpectation{
		mock:   mmDel.mock,
		params: &StorageLayerMockDelParams{ctx, s1},
	}
	mmDel.expectations = append(mmDel.expectations, expectation)
	return expectation
}

// Then sets up storageLayer.Del return parameters for the expectation previously defined by the When method
func (e *StorageLayerMockDelExpectation) Then(err error) *StorageLayerMock {
	e.results = &StorageLayerMockDelResults{err}
	return e.mock
}

// Del implements database.storageLayer
func (mmDel *StorageLayerMock) Del(ctx context.Context, s1 string) (err error) {
	mm_atomic.AddUint64(&mmDel.beforeDelCounter, 1)
	defer mm_atomic.AddUint64(&mmDel.afterDelCounter, 1)

	if mmDel.inspectFuncDel != nil {
		mmDel.inspectFuncDel(ctx, s1)
	}

	mm_params := StorageLayerMockDelParams{ctx, s1}

	// Record call args
	mmDel.DelMock.mutex.Lock()
	mmDel.DelMock.callArgs = append(mmDel.DelMock.callArgs, &mm_params)
	mmDel.DelMock.mutex.Unlock()

	for _, e := range mmDel.DelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDel.DelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDel.DelMock.defaultExpectation.Counter, 1)
		mm_want := mmDel.DelMock.defaultExpectation.params
		mm_got := StorageLayerMockDelParams{ctx, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDel.t.Errorf("StorageLayerMock.Del got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDel.DelMock.defaultExpectation.results
		if mm_results == nil {
			mmDel.t.Fatal("No results are set for the StorageLayerMock.Del")
		}
		return (*mm_results).err
	}
	if mmDel.funcDel != nil {
		return mmDel.funcDel(ctx, s1)
	}
	mmDel.t.Fatalf("Unexpected call to StorageLayerMock.Del. %v %v", ctx, s1)
	return
}

// DelAfterCounter returns a count of finished StorageLayerMock.Del invocations
func (mmDel *StorageLayerMock) DelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDel.afterDelCounter)
}

// DelBeforeCounter returns a count of StorageLayerMock.Del invocations
func (mmDel *StorageLayerMock) DelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDel.beforeDelCounter)
}

// Calls returns a list of arguments used in each call to StorageLayerMock.Del.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDel *mStorageLayerMockDel) Calls() []*StorageLayerMockDelParams {
	mmDel.mutex.RLock()

	argCopy := make([]*StorageLayerMockDelParams, len(mmDel.callArgs))
	copy(argCopy, mmDel.callArgs)

	mmDel.mutex.RUnlock()

	return argCopy
}

// MinimockDelDone returns true if the count of the Del invocations corresponds
// the number of defined expectations
func (m *StorageLayerMock) MinimockDelDone() bool {
	for _, e := range m.DelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDelCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDel != nil && mm_atomic.LoadUint64(&m.afterDelCounter) < 1 {
		return false
	}
	return true
}

// MinimockDelInspect logs each unmet expectation
func (m *StorageLayerMock) MinimockDelInspect() {
	for _, e := range m.DelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageLayerMock.Del with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDelCounter) < 1 {
		if m.DelMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageLayerMock.Del")
		} else {
			m.t.Errorf("Expected call to StorageLayerMock.Del with params: %#v", *m.DelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDel != nil && mm_atomic.LoadUint64(&m.afterDelCounter) < 1 {
		m.t.Error("Expected call to StorageLayerMock.Del")
	}
}

type mStorageLayerMockGet struct {
	mock               *StorageLayerMock
	defaultExpectation *StorageLayerMockGetExpectation
	expectations       []*StorageLayerMockGetExpectation

	callArgs []*StorageLayerMockGetParams
	mutex    sync.RWMutex
}

// StorageLayerMockGetExpectation specifies expectation struct of the storageLayer.Get
type StorageLayerMockGetExpectation struct {
	mock    *StorageLayerMock
	params  *StorageLayerMockGetParams
	results *StorageLayerMockGetResults
	Counter uint64
}

// StorageLayerMockGetParams contains parameters of the storageLayer.Get
type StorageLayerMockGetParams struct {
	ctx context.Context
	s1  string
}

// StorageLayerMockGetResults contains results of the storageLayer.Get
type StorageLayerMockGetResults struct {
	s2  string
	err error
}

// Expect sets up expected params for storageLayer.Get
func (mmGet *mStorageLayerMockGet) Expect(ctx context.Context, s1 string) *mStorageLayerMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("StorageLayerMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &StorageLayerMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &StorageLayerMockGetParams{ctx, s1}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the storageLayer.Get
func (mmGet *mStorageLayerMockGet) Inspect(f func(ctx context.Context, s1 string)) *mStorageLayerMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for StorageLayerMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by storageLayer.Get
func (mmGet *mStorageLayerMockGet) Return(s2 string, err error) *StorageLayerMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("StorageLayerMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &StorageLayerMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &StorageLayerMockGetResults{s2, err}
	return mmGet.mock
}

// Set uses given function f to mock the storageLayer.Get method
func (mmGet *mStorageLayerMockGet) Set(f func(ctx context.Context, s1 string) (s2 string, err error)) *StorageLayerMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the storageLayer.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the storageLayer.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the storageLayer.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mStorageLayerMockGet) When(ctx context.Context, s1 string) *StorageLayerMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("StorageLayerMock.Get mock is already set by Set")
	}

	expectation := &StorageLayerMockGetExpectation{
		mock:   mmGet.mock,
		params: &StorageLayerMockGetParams{ctx, s1},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up storageLayer.Get return parameters for the expectation previously defined by the When method
func (e *StorageLayerMockGetExpectation) Then(s2 string, err error) *StorageLayerMock {
	e.results = &StorageLayerMockGetResults{s2, err}
	return e.mock
}

// Get implements database.storageLayer
func (mmGet *StorageLayerMock) Get(ctx context.Context, s1 string) (s2 string, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, s1)
	}

	mm_params := StorageLayerMockGetParams{ctx, s1}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := StorageLayerMockGetParams{ctx, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("StorageLayerMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the StorageLayerMock.Get")
		}
		return (*mm_results).s2, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, s1)
	}
	mmGet.t.Fatalf("Unexpected call to StorageLayerMock.Get. %v %v", ctx, s1)
	return
}

// GetAfterCounter returns a count of finished StorageLayerMock.Get invocations
func (mmGet *StorageLayerMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of StorageLayerMock.Get invocations
func (mmGet *StorageLayerMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to StorageLayerMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mStorageLayerMockGet) Calls() []*StorageLayerMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*StorageLayerMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *StorageLayerMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *StorageLayerMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageLayerMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageLayerMock.Get")
		} else {
			m.t.Errorf("Expected call to StorageLayerMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to StorageLayerMock.Get")
	}
}

type mStorageLayerMockSet struct {
	mock               *StorageLayerMock
	defaultExpectation *StorageLayerMockSetExpectation
	expectations       []*StorageLayerMockSetExpectation

	callArgs []*StorageLayerMockSetParams
	mutex    sync.RWMutex
}

// StorageLayerMockSetExpectation specifies expectation struct of the storageLayer.Set
type StorageLayerMockSetExpectation struct {
	mock    *StorageLayerMock
	params  *StorageLayerMockSetParams
	results *StorageLayerMockSetResults
	Counter uint64
}

// StorageLayerMockSetParams contains parameters of the storageLayer.Set
type StorageLayerMockSetParams struct {
	ctx context.Context
	s1  string
	s2  string
}

// StorageLayerMockSetResults contains results of the storageLayer.Set
type StorageLayerMockSetResults struct {
	err error
}

// Expect sets up expected params for storageLayer.Set
func (mmSet *mStorageLayerMockSet) Expect(ctx context.Context, s1 string, s2 string) *mStorageLayerMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("StorageLayerMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &StorageLayerMockSetExpectation{}
	}

	mmSet.defaultExpectation.params = &StorageLayerMockSetParams{ctx, s1, s2}
	for _, e := range mmSet.expectations {
		if minimock.Equal(e.params, mmSet.defaultExpectation.params) {
			mmSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSet.defaultExpectation.params)
		}
	}

	return mmSet
}

// Inspect accepts an inspector function that has same arguments as the storageLayer.Set
func (mmSet *mStorageLayerMockSet) Inspect(f func(ctx context.Context, s1 string, s2 string)) *mStorageLayerMockSet {
	if mmSet.mock.inspectFuncSet != nil {
		mmSet.mock.t.Fatalf("Inspect function is already set for StorageLayerMock.Set")
	}

	mmSet.mock.inspectFuncSet = f

	return mmSet
}

// Return sets up results that will be returned by storageLayer.Set
func (mmSet *mStorageLayerMockSet) Return(err error) *StorageLayerMock {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("StorageLayerMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &StorageLayerMockSetExpectation{mock: mmSet.mock}
	}
	mmSet.defaultExpectation.results = &StorageLayerMockSetResults{err}
	return mmSet.mock
}

// Set uses given function f to mock the storageLayer.Set method
func (mmSet *mStorageLayerMockSet) Set(f func(ctx context.Context, s1 string, s2 string) (err error)) *StorageLayerMock {
	if mmSet.defaultExpectation != nil {
		mmSet.mock.t.Fatalf("Default expectation is already set for the storageLayer.Set method")
	}

	if len(mmSet.expectations) > 0 {
		mmSet.mock.t.Fatalf("Some expectations are already set for the storageLayer.Set method")
	}

	mmSet.mock.funcSet = f
	return mmSet.mock
}

// When sets expectation for the storageLayer.Set which will trigger the result defined by the following
// Then helper
func (mmSet *mStorageLayerMockSet) When(ctx context.Context, s1 string, s2 string) *StorageLayerMockSetExpectation {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("StorageLayerMock.Set mock is already set by Set")
	}

	expectation := &StorageLayerMockSetExpectation{
		mock:   mmSet.mock,
		params: &StorageLayerMockSetParams{ctx, s1, s2},
	}
	mmSet.expectations = append(mmSet.expectations, expectation)
	return expectation
}

// Then sets up storageLayer.Set return parameters for the expectation previously defined by the When method
func (e *StorageLayerMockSetExpectation) Then(err error) *StorageLayerMock {
	e.results = &StorageLayerMockSetResults{err}
	return e.mock
}

// Set implements database.storageLayer
func (mmSet *StorageLayerMock) Set(ctx context.Context, s1 string, s2 string) (err error) {
	mm_atomic.AddUint64(&mmSet.beforeSetCounter, 1)
	defer mm_atomic.AddUint64(&mmSet.afterSetCounter, 1)

	if mmSet.inspectFuncSet != nil {
		mmSet.inspectFuncSet(ctx, s1, s2)
	}

	mm_params := StorageLayerMockSetParams{ctx, s1, s2}

	// Record call args
	mmSet.SetMock.mutex.Lock()
	mmSet.SetMock.callArgs = append(mmSet.SetMock.callArgs, &mm_params)
	mmSet.SetMock.mutex.Unlock()

	for _, e := range mmSet.SetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSet.SetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSet.SetMock.defaultExpectation.Counter, 1)
		mm_want := mmSet.SetMock.defaultExpectation.params
		mm_got := StorageLayerMockSetParams{ctx, s1, s2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSet.t.Errorf("StorageLayerMock.Set got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSet.SetMock.defaultExpectation.results
		if mm_results == nil {
			mmSet.t.Fatal("No results are set for the StorageLayerMock.Set")
		}
		return (*mm_results).err
	}
	if mmSet.funcSet != nil {
		return mmSet.funcSet(ctx, s1, s2)
	}
	mmSet.t.Fatalf("Unexpected call to StorageLayerMock.Set. %v %v %v", ctx, s1, s2)
	return
}

// SetAfterCounter returns a count of finished StorageLayerMock.Set invocations
func (mmSet *StorageLayerMock) SetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.afterSetCounter)
}

// SetBeforeCounter returns a count of StorageLayerMock.Set invocations
func (mmSet *StorageLayerMock) SetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.beforeSetCounter)
}

// Calls returns a list of arguments used in each call to StorageLayerMock.Set.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSet *mStorageLayerMockSet) Calls() []*StorageLayerMockSetParams {
	mmSet.mutex.RLock()

	argCopy := make([]*StorageLayerMockSetParams, len(mmSet.callArgs))
	copy(argCopy, mmSet.callArgs)

	mmSet.mutex.RUnlock()

	return argCopy
}

// MinimockSetDone returns true if the count of the Set invocations corresponds
// the number of defined expectations
func (m *StorageLayerMock) MinimockSetDone() bool {
	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSet != nil && mm_atomic.LoadUint64(&m.afterSetCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetInspect logs each unmet expectation
func (m *StorageLayerMock) MinimockSetInspect() {
	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageLayerMock.Set with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetCounter) < 1 {
		if m.SetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageLayerMock.Set")
		} else {
			m.t.Errorf("Expected call to StorageLayerMock.Set with params: %#v", *m.SetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSet != nil && mm_atomic.LoadUint64(&m.afterSetCounter) < 1 {
		m.t.Error("Expected call to StorageLayerMock.Set")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageLayerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDelInspect()

			m.MinimockGetInspect()

			m.MinimockSetInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageLayerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageLayerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDelDone() &&
		m.MinimockGetDone() &&
		m.MinimockSetDone()
}

package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// EngineMock implements storage.Engine
type EngineMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDel          func(ctx context.Context, s1 string)
	inspectFuncDel   func(ctx context.Context, s1 string)
	afterDelCounter  uint64
	beforeDelCounter uint64
	DelMock          mEngineMockDel

	funcGet          func(ctx context.Context, s1 string) (s2 string, b1 bool)
	inspectFuncGet   func(ctx context.Context, s1 string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mEngineMockGet

	funcSet          func(ctx context.Context, s1 string, s2 string)
	inspectFuncSet   func(ctx context.Context, s1 string, s2 string)
	afterSetCounter  uint64
	beforeSetCounter uint64
	SetMock          mEngineMockSet
}

// NewEngineMock returns a mock for storage.Engine
func NewEngineMock(t minimock.Tester) *EngineMock {
	m := &EngineMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DelMock = mEngineMockDel{mock: m}
	m.DelMock.callArgs = []*EngineMockDelParams{}

	m.GetMock = mEngineMockGet{mock: m}
	m.GetMock.callArgs = []*EngineMockGetParams{}

	m.SetMock = mEngineMockSet{mock: m}
	m.SetMock.callArgs = []*EngineMockSetParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mEngineMockDel struct {
	mock               *EngineMock
	defaultExpectation *EngineMockDelExpectation
	expectations       []*EngineMockDelExpectation

	callArgs []*EngineMockDelParams
	mutex    sync.RWMutex
}

// EngineMockDelExpectation specifies expectation struct of the Engine.Del
type EngineMockDelExpectation struct {
	mock   *EngineMock
	params *EngineMockDelParams

	Counter uint64
}

// EngineMockDelParams contains parameters of the Engine.Del
type EngineMockDelParams struct {
	ctx context.Context
	s1  string
}

// Expect sets up expected params for Engine.Del
func (mmDel *mEngineMockDel) Expect(ctx context.Context, s1 string) *mEngineMockDel {
	if mmDel.mock.funcDel != nil {
		mmDel.mock.t.Fatalf("EngineMock.Del mock is already set by Set")
	}

	if mmDel.defaultExpectation == nil {
		mmDel.defaultExpectation = &EngineMockDelExpectation{}
	}

	mmDel.defaultExpectation.params = &EngineMockDelParams{ctx, s1}
	for _, e := range mmDel.expectations {
		if minimock.Equal(e.params, mmDel.defaultExpectation.params) {
			mmDel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDel.defaultExpectation.params)
		}
	}

	return mmDel
}

// Inspect accepts an inspector function that has same arguments as the Engine.Del
func (mmDel *mEngineMockDel) Inspect(f func(ctx context.Context, s1 string)) *mEngineMockDel {
	if mmDel.mock.inspectFuncDel != nil {
		mmDel.mock.t.Fatalf("Inspect function is already set for EngineMock.Del")
	}

	mmDel.mock.inspectFuncDel = f

	return mmDel
}

// Return sets up results that will be returned by Engine.Del
func (mmDel *mEngineMockDel) Return() *EngineMock {
	if mmDel.mock.funcDel != nil {
		mmDel.mock.t.Fatalf("EngineMock.Del mock is already set by Set")
	}

	if mmDel.defaultExpectation == nil {
		mmDel.defaultExpectation = &EngineMockDelExpectation{mock: mmDel.mock}
	}

	return mmDel.mock
}

// Set uses given function f to mock the Engine.Del method
func (mmDel *mEngineMockDel) Set(f func(ctx context.Context, s1 string)) *EngineMock {
	if mmDel.defaultExpectation != nil {
		mmDel.mock.t.Fatalf("Default expectation is already set for the Engine.Del method")
	}

	if len(mmDel.expectations) > 0 {
		mmDel.mock.t.Fatalf("Some expectations are already set for the Engine.Del method")
	}

	mmDel.mock.funcDel = f
	return mmDel.mock
}

// Del implements storage.Engine
func (mmDel *EngineMock) Del(ctx context.Context, s1 string) {
	mm_atomic.AddUint64(&mmDel.beforeDelCounter, 1)
	defer mm_atomic.AddUint64(&mmDel.afterDelCounter, 1)

	if mmDel.inspectFuncDel != nil {
		mmDel.inspectFuncDel(ctx, s1)
	}

	mm_params := EngineMockDelParams{ctx, s1}

	// Record call args
	mmDel.DelMock.mutex.Lock()
	mmDel.DelMock.callArgs = append(mmDel.DelMock.callArgs, &mm_params)
	mmDel.DelMock.mutex.Unlock()

	for _, e := range mmDel.DelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDel.DelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDel.DelMock.defaultExpectation.Counter, 1)
		mm_want := mmDel.DelMock.defaultExpectation.params
		mm_got := EngineMockDelParams{ctx, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDel.t.Errorf("EngineMock.Del got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDel.funcDel != nil {
		mmDel.funcDel(ctx, s1)
		return
	}
	mmDel.t.Fatalf("Unexpected call to EngineMock.Del. %v %v", ctx, s1)

}

// DelAfterCounter returns a count of finished EngineMock.Del invocations
func (mmDel *EngineMock) DelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDel.afterDelCounter)
}

// DelBeforeCounter returns a count of EngineMock.Del invocations
func (mmDel *EngineMock) DelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDel.beforeDelCounter)
}

// Calls returns a list of arguments used in each call to EngineMock.Del.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDel *mEngineMockDel) Calls() []*EngineMockDelParams {
	mmDel.mutex.RLock()

	argCopy := make([]*EngineMockDelParams, len(mmDel.callArgs))
	copy(argCopy, mmDel.callArgs)

	mmDel.mutex.RUnlock()

	return argCopy
}

// MinimockDelDone returns true if the count of the Del invocations corresponds
// the number of defined expectations
func (m *EngineMock) MinimockDelDone() bool {
	for _, e := range m.DelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDelCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDel != nil && mm_atomic.LoadUint64(&m.afterDelCounter) < 1 {
		return false
	}
	return true
}

// MinimockDelInspect logs each unmet expectation
func (m *EngineMock) MinimockDelInspect() {
	for _, e := range m.DelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EngineMock.Del with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDelCounter) < 1 {
		if m.DelMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EngineMock.Del")
		} else {
			m.t.Errorf("Expected call to EngineMock.Del with params: %#v", *m.DelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDel != nil && mm_atomic.LoadUint64(&m.afterDelCounter) < 1 {
		m.t.Error("Expected call to EngineMock.Del")
	}
}

type mEngineMockGet struct {
	mock               *EngineMock
	defaultExpectation *EngineMockGetExpectation
	expectations       []*EngineMockGetExpectation

	callArgs []*EngineMockGetParams
	mutex    sync.RWMutex
}

// EngineMockGetExpectation specifies expectation struct of the Engine.Get
type EngineMockGetExpectation struct {
	mock    *EngineMock
	params  *EngineMockGetParams
	results *EngineMockGetResults
	Counter uint64
}

// EngineMockGetParams contains parameters of the Engine.Get
type EngineMockGetParams struct {
	ctx context.Context
	s1  string
}

// EngineMockGetResults contains results of the Engine.Get
type EngineMockGetResults struct {
	s2 string
	b1 bool
}

// Expect sets up expected params for Engine.Get
func (mmGet *mEngineMockGet) Expect(ctx context.Context, s1 string) *mEngineMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("EngineMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &EngineMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &EngineMockGetParams{ctx, s1}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the Engine.Get
func (mmGet *mEngineMockGet) Inspect(f func(ctx context.Context, s1 string)) *mEngineMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for EngineMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by Engine.Get
func (mmGet *mEngineMockGet) Return(s2 string, b1 bool) *EngineMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("EngineMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &EngineMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &EngineMockGetResults{s2, b1}
	return mmGet.mock
}

// Set uses given function f to mock the Engine.Get method
func (mmGet *mEngineMockGet) Set(f func(ctx context.Context, s1 string) (s2 string, b1 bool)) *EngineMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the Engine.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the Engine.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the Engine.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mEngineMockGet) When(ctx context.Context, s1 string) *EngineMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("EngineMock.Get mock is already set by Set")
	}

	expectation := &EngineMockGetExpectation{
		mock:   mmGet.mock,
		params: &EngineMockGetParams{ctx, s1},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up Engine.Get return parameters for the expectation previously defined by the When method
func (e *EngineMockGetExpectation) Then(s2 string, b1 bool) *EngineMock {
	e.results = &EngineMockGetResults{s2, b1}
	return e.mock
}

// Get implements storage.Engine
func (mmGet *EngineMock) Get(ctx context.Context, s1 string) (s2 string, b1 bool) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, s1)
	}

	mm_params := EngineMockGetParams{ctx, s1}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2, e.results.b1
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := EngineMockGetParams{ctx, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("EngineMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the EngineMock.Get")
		}
		return (*mm_results).s2, (*mm_results).b1
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, s1)
	}
	mmGet.t.Fatalf("Unexpected call to EngineMock.Get. %v %v", ctx, s1)
	return
}

// GetAfterCounter returns a count of finished EngineMock.Get invocations
func (mmGet *EngineMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of EngineMock.Get invocations
func (mmGet *EngineMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to EngineMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mEngineMockGet) Calls() []*EngineMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*EngineMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *EngineMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *EngineMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EngineMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EngineMock.Get")
		} else {
			m.t.Errorf("Expected call to EngineMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to EngineMock.Get")
	}
}

type mEngineMockSet struct {
	mock               *EngineMock
	defaultExpectation *EngineMockSetExpectation
	expectations       []*EngineMockSetExpectation

	callArgs []*EngineMockSetParams
	mutex    sync.RWMutex
}

// EngineMockSetExpectation specifies expectation struct of the Engine.Set
type EngineMockSetExpectation struct {
	mock   *EngineMock
	params *EngineMockSetParams

	Counter uint64
}

// EngineMockSetParams contains parameters of the Engine.Set
type EngineMockSetParams struct {
	ctx context.Context
	s1  string
	s2  string
}

// Expect sets up expected params for Engine.Set
func (mmSet *mEngineMockSet) Expect(ctx context.Context, s1 string, s2 string) *mEngineMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("EngineMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &EngineMockSetExpectation{}
	}

	mmSet.defaultExpectation.params = &EngineMockSetParams{ctx, s1, s2}
	for _, e := range mmSet.expectations {
		if minimock.Equal(e.params, mmSet.defaultExpectation.params) {
			mmSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSet.defaultExpectation.params)
		}
	}

	return mmSet
}

// Inspect accepts an inspector function that has same arguments as the Engine.Set
func (mmSet *mEngineMockSet) Inspect(f func(ctx context.Context, s1 string, s2 string)) *mEngineMockSet {
	if mmSet.mock.inspectFuncSet != nil {
		mmSet.mock.t.Fatalf("Inspect function is already set for EngineMock.Set")
	}

	mmSet.mock.inspectFuncSet = f

	return mmSet
}

// Return sets up results that will be returned by Engine.Set
func (mmSet *mEngineMockSet) Return() *EngineMock {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("EngineMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &EngineMockSetExpectation{mock: mmSet.mock}
	}

	return mmSet.mock
}

// Set uses given function f to mock the Engine.Set method
func (mmSet *mEngineMockSet) Set(f func(ctx context.Context, s1 string, s2 string)) *EngineMock {
	if mmSet.defaultExpectation != nil {
		mmSet.mock.t.Fatalf("Default expectation is already set for the Engine.Set method")
	}

	if len(mmSet.expectations) > 0 {
		mmSet.mock.t.Fatalf("Some expectations are already set for the Engine.Set method")
	}

	mmSet.mock.funcSet = f
	return mmSet.mock
}

// Set implements storage.Engine
func (mmSet *EngineMock) Set(ctx context.Context, s1 string, s2 string) {
	mm_atomic.AddUint64(&mmSet.beforeSetCounter, 1)
	defer mm_atomic.AddUint64(&mmSet.afterSetCounter, 1)

	if mmSet.inspectFuncSet != nil {
		mmSet.inspectFuncSet(ctx, s1, s2)
	}

	mm_params := EngineMockSetParams{ctx, s1, s2}

	// Record call args
	mmSet.SetMock.mutex.Lock()
	mmSet.SetMock.callArgs = append(mmSet.SetMock.callArgs, &mm_params)
	mmSet.SetMock.mutex.Unlock()

	for _, e := range mmSet.SetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSet.SetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSet.SetMock.defaultExpectation.Counter, 1)
		mm_want := mmSet.SetMock.defaultExpectation.params
		mm_got := EngineMockSetParams{ctx, s1, s2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSet.t.Errorf("EngineMock.Set got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSet.funcSet != nil {
		mmSet.funcSet(ctx, s1, s2)
		return
	}
	mmSet.t.Fatalf("Unexpected call to EngineMock.Set. %v %v %v", ctx, s1, s2)

}

// SetAfterCounter returns a count of finished EngineMock.Set invocations
func (mmSet *EngineMock) SetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.afterSetCounter)
}

// SetBeforeCounter returns a count of EngineMock.Set invocations
func (mmSet *EngineMock) SetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.beforeSetCounter)
}

// Calls returns a list of arguments used in each call to EngineMock.Set.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSet *mEngineMockSet) Calls() []*EngineMockSetParams {
	mmSet.mutex.RLock()

	argCopy := make([]*EngineMockSetParams, len(mmSet.callArgs))
	copy(argCopy, mmSet.callArgs)

	mmSet.mutex.RUnlock()

	return argCopy
}

// MinimockSetDone returns true if the count of the Set invocations corresponds
// the number of defined expectations
func (m *EngineMock) MinimockSetDone() bool {
	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSet != nil && mm_atomic.LoadUint64(&m.afterSetCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetInspect logs each unmet expectation
func (m *EngineMock) MinimockSetInspect() {
	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EngineMock.Set with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetCounter) < 1 {
		if m.SetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EngineMock.Set")
		} else {
			m.t.Errorf("Expected call to EngineMock.Set with params: %#v", *m.SetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSet != nil && mm_atomic.LoadUint64(&m.afterSetCounter) < 1 {
		m.t.Error("Expected call to EngineMock.Set")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *EngineMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDelInspect()

			m.MinimockGetInspect()

			m.MinimockSetInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *EngineMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *EngineMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDelDone() &&
		m.MinimockGetDone() &&
		m.MinimockSetDone()
}
